# JavaScript 内存管理与垃圾回收

JavaScript 的在创建变量时分配内存，并像 Java 一样在不再使用的时候进行**垃圾回收（GC）**。

## 内存的生命周期

大多数的程序语言的生命周期都是一致的：

1. 分配内存
2. 使用分配到的内存（读或写）
3. 在不需要的时候释放

### JavaScript 的内存分配

> 值的初始化。JavaScript 在定义变量的时候就完成了内存分配

```js
const num = 123; // 给数值变量分配内存
const str = 'alex'; // 给字符串分配内存

// 给对象及其包含的值分配内存
const obj = {
  a: 1,
  b: null
}; 

const arr = [1, null, "abra"]; // 给数组及其包含的值分配内存（就像对象一样

// 给函数（可调用的对象）分配内存
function func(a){
  return a + 2;
} 

// 函数表达式也能分配一个对象
someElement.addEventListener('click', function() {
  someElement.style.backgroundColor = 'blue';
}, false);

```

> 通过函数调用分配内存。

```js
const today = new Date(); // 通过构造函数

const $ele = document.createElement('div');

```

## 垃圾回收

> 垃圾回收算法主要依赖于引用的概念。

### 引用

一个对象如果有隐式（例如对原型的引用）或显示（例如对属性的引用）的访问另一个对象的权限，就叫做一个对象引用另一个对象。

_这里的“对象”不仅仅指 JavaScript 对象，还包括函数作用域或全局词法作用域_



### 垃圾回收算法

JavaScript 中常见的垃圾回收算法有两类：

* 引用计数法
* 标记清除法

Java 或其它的编程语言的内存回收算法种类可能更多，例如，复制法，标记整理法，分代收集法等。



#### 引用计数法

引用计数法的套路是：每个对象都有一个计数器，当这个对象被引用时，计数器加 1，当断开一个引用时，计数器减 1，当进行 GC 时，回收那些计数器为 0 的对象。

```js
// 通过字面量创建一个对象
// 在内存中，实际上是可能是创建 3 个"对象"，。
let obj = {
    a: {
        b: 2,
    }
}

let obj2 = obj; // obj 指向的对象（A）新增一个引用。
obj = null; // 原先的对象（A）的原始引用被 obj2 替换

let obj3 = obj2.a; // 引用对象（A）的属性 a，这个属性指向的对象（B）增加一个引用

obj2 = null； // 对象（A）当前引用为 0，可以被回收。属性 a 指向的对象（B）引用不为 0，无法回收

obj3 = null // 对象（B），当前引用为 0，可以被回收
```

> 引用计数法无法处理循环引用

```js
function func() {
    const obj = {};
    const obj2 = {};
    obj.a = obj2;
    obj2.a = obj;
}
func(); // 在采用引用计数法进行 GC JavaScript 环境中，func 内造成的循环引用会导致创建的内存无法被回收

```

#### 

#### 标记-清除法

**标记-清除法**，假定设置一个 root 对象（JavaScript 中，root 是 `global`/`window` 对象）。定期的，GC 将从根节点开始遍历被引用的对象，对能够被查到的对象进行标记。然后再次遍历整个内存空间，回收未被标记的对象。

标记清除法能够解决引用计数法无法处理的循环引用的问题。

目前大多数现代浏览器都采用了标记-清除垃圾回收算法。



